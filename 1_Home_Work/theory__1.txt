Теория home_work_1

0. Сигнатура  - это часть объявления функции, в С++ функция опознаётся компилятором по её имени и последовательности аргументов (и их типов), что и есть сигнатура. Различие в функциях составляются типы и количество аргументов, но не тип возвращаемого значения функцией. Например:

void swop (int* a, int* b);
void swop (int* a, int* b, int * c); // различные функции

void swop (int* a, int* b);
int swop (int* a, int* b); // одинаковые функции

void swop (int* a, int* b);
void swop (uint_64* a, uint_64* b); // различные функции

1. Полиморфизм — способность функции обрабатывать данные разных типов. В С мы писали функцию swop для int, однако чтобы эта же фукнция работала для других типов данных, нажо писать для них отдельные программы. В С++ мы можем написать 1 программу для разных типов данных с помощью шаблонов. Выбор нужной программы происходит на этапе выполнения.
template <typename T>
void swop (T* a, T* b);

2. Перегрузка функций — это возможность использования одноимённых программ (функций). Перегружаемые функции имеют одно и то же имя, но разное количество аргументов или они с разными типами. Какую функцию вызвать? По списку её аргументов при вызове функции на этапе компиляции.
Например:
int volume (int s);
double volume (double s);
double volume (double h, int r);
Мы либо меяли число аргументов, либо их тип.

3. Аргументы по умолчанию -  это такие параметры функиции, которые имеют определённое значение по умолчанию, если пользователь не передаёт в функцию значение для параметра по умолчанию, то будет использоваться то, что по умолчанию, а если передаёт, то введённое пользователем. Если мы хотим использовать аргументы по умолчанию, то мы должны прописывать их самыми правыми относительно других аргументов, то есть нельзя прописать сначала аргумент по умолчанию, а затем обычный.

void  args (int a, int b, int c = 5) {…….}
...
args (1, 2); // в функции будут использоваться значения 1, 2, 5
args (1, 2, 3); // в функции будут использоваться значения аргументов 1, 2, 3

4. Шаблон функции — это как некая инструкция того, как будет выглядеть функция для конкретных аргументов. Без шаблонов чтобы работала функция с четырьмя различными типами аргументов нужно написать 4 идентичные функции, то есть воспользуемся перегрузкой функции. От настоящей функции шаблон отличает то, что мы не указываем явно, какой тип данных нам поступит в аргументы, а прописываем строку template <typename T>  например, и дальше вместо всех типов данных в аргументе пишем T. Но у шаблонов есть ограничения, например, мы предполагаем, что  a = b определена операция присваивания, но это может оказаться не так, если типом T является массив, то же происходит с операциями сравнения или умножения, то есть мы получим шаблон, который не может обрабатывать некоторые типы, так как подобные операции для них могут быть просто не определены.

5. Явные специализации — это специализированное объявление шаблонов для отдельных типов. Если компилятор обнаруживает явную специализацию, которая точно соответствует вызову функции, то он использует её без поиска шаблонов.  Пример из Прата:допустим, у нас есть структура, описанная так:
struct job 
{
	char name [40];
	double salary ;
	int floor;
}; 
И мы хотим обеспечить обмен содержимым внутри структуры. 
// прототип не шаблонной функции будет выглядеть так:
 void swop (job &, job &);
//прототип шаблона:
template  <typename T>
void swop (T &, T &);
//Явная специализация:
template <>
void swap <job> (job &, job &);

6. Ссылка представляет собой имя, которое является альтернативным именем для ранее объявленной переменной. Этот объект указывает на некоторые данные, но не хранит их. Что отличает её от указателя? Всё проще чем с указателями, не надо никаких дополнительных символов, и ещё его нельзя изменить, только один раз инициализируем и всё.

7. inline это встроенная функция для того, чтобы компилятор заменял вызов функции каждый раз на фактический код из этой функции. Это ускоряет работу программы за счёт памяти, просто потому что вызов функции занимает больше времени, чем вставка кода.

8. decltype определяет тип значения, возвращаемого выражением.
auto это слово, которое было в С, но в С++ его переопределили (единственный пример такого) заново, теперь он определяет тип переменной, например:
int a = 0;
auto c = a;