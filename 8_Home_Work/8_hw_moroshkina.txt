0) Шаблон класса - это правила, по которым программа создаёт мини-копии нашего класса, но для конкретных входных данных. Они нужны для того, что кучу раз не писать почти один и тот же код для разных входных данных.

1) Аргументом шаблона может быть какой-то тип данных, либо конкретное значение(в роли параметров шаблонов могут выступать целочисленные константы (включая перечисления) или указатели на объекты с внешним связыванием. Использование чисел с плавающей точкой и объектов с типом класса в качестве параметров шаблона не допускается), например:

template <typename T, int MAXSIZE>	//первый параметр шаблона - тип, второй параметр не тип, а прямое значеник как у параметра функции

2) Рекурсивное использование шаблонов допускается. Мы можем использовать шаблоны в шаблонах, и этот факт может быть применён, например, для вычисления какого-либо ряда или полинома

#include <iostream>
using namespace std;
template <int i> int func() {
    return func<i-1>()+i;
};
template <> int func<0>() {
    return 0;
};
int main () {
   cout << func<10>() << endl;
   return 0;
};
//кусочек программы взят с сайта habr.com

3) Нам позволено создавать шаблоны с несколькими аргументами, и в принципе их количес тво ничем не ограничено. template <typename T0, typename T1>

4) Формальные параметры шаблона могут иметь значения по умолчанию. Синтаксически это оформляется путём добавления после имени параметра знака «=», за которым следует значение:

template < typenameT = double, intM = 3, intN = 3> classMY

Если формальный параметр шаблона имеет значение по умолчанию, то все следующие за ним параметры также должны иметь значения по умолчанию. Нельзя чтобы сначала следовал параметр по умолчанию, а затем нет.

5) Вот у нас есть шаблон, в котором описаны правила того, как надо выполнять функцию для разных типов входных данных. Но есть какой-то типа, у которого мы хотим прописать иную реализацию той же самой функции. Для этого есть явная специализация. Если мы хотим задать явную специалихацию для функции, то альтернативным вариантом может служить просто пепрегрузка функции, а вот явную специализацию лучше использовать ждля каого-либо класса. Компилятор видит сначала только базовые шаблоны, а только после того, как станет ясно, какой шаблон нам нужен, выбирается необходимая явная специализация, отнесённая именно к этому базовому шаблону. Если мы нарушим порядок следования базовог шаблона и специализации, то эта специализация может быть отнесена к дркгомку базовому шаблону и на этапе компиляции не рассматриваться.

6) Можно, при условии что сама функция будет корректно работать с поступающим типом данных, ведь если какая-то операция попросту не определена, то бдует всё плохо.

7) Нет, так как передастся только первый объект, потому что только этот объект подходит по типу шаблона, второрй же является экземпляром другого шаблона для класса.