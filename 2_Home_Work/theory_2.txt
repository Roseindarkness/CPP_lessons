								Теория 2

    0) Существует автоматический тип памяти для локальных переменных. Память выделяется на стеке. Время существования таких переменных только внутри области видимости. Переменные автоматическими становятся стаовятся по умолчанию после определения внутри функции. Поэтому кодовопе слово auto  используетя крайне редко и потом в С++ его переопределили заново.
    Так же есть регистровый тип памяти с ключевым словом register. Когда мы опредлеяем регистровую переменную, мы хотим, чтобы компилятор выделял память на регистре, а не в оперативной памяти. Регистровые пермеенные не имеют адрес, следовательно нельзя взять адрес переменной. Регистр это блок ячеек памяти, который образует сверхбыструю оперативную память. 
    Статический тип используется с ключевым словом static. Тут мы указываем компилятору, что мы хотим, чтобы локальная переменная жила на протяжении всего жизненного цикла программы, а не создавалась и разрушалась.
    Внешний тип с ключевым словом external. Это как противоположность автоматическим переменным, то есть глобальные переменные, к которым можно обращаться из любой функции. Они нам нужны в двух случаях, когда мы хотим объявить переменную после того, как используем её, либо когда она определена в другой функции.
	
	1) Есть локальные и глобальные переменные. Если мы объявляем переменную вне какой-либо функции, то она будет глобальной. Локальные переменные мы будем создавать внути фукнции, причём область видимости по сути ограничивается скобочками {}, внутри которых объявляется переменная. Если в функции есть несколько скобочек, то мы можем создать 2 переменные с одинаковым нахванием, но существующие в разных областях видимости.

	2-3) Отличие в С++ состоит в том, что добавляются ещё такие способы управления областями видимости, как специальные слова с ограничением доступа: private, public, protected.
	Public - доступ есть у всех и отовсюду, кто можетвидеть наш класс, то есть внутри области видимости класса.
	private - доступны только внутри класса и у дружественных фукнций, больше никому, в том числе наследникам, нельзя иметь доступ к приватным фунцим класса.
	protected - для всяких посторонних классов по прежнему не доступны, однако внутри своего класса и все наследники могут иметь доступ к этим фукнциям.

	namespace это пространство имён. Привидённая в википедии понятная мне аналогия заключается в том, что есть 2 человека с одинаковым ID 123, но работающие в разных компаниях. Когда бухгалтерии нужно начислять им зарплату, могут возникнуть трудности, какому специалисту по ID 123 перевести ту или иную сумму? Для этого нужно ассоциировать одного работника с одной компанией, а второго с другой. Для этого по сути и нужен namespace. Чтобы не было проблемы с возможным совпадением имён.

	4) Конструктор это специальный метод класса, предназначенный для инициализации объектов класса, а деструктор для их уничтожения. Эти функции мы обязательно делаем публичными. У них нет типа вовзращаемого значения и деструктору нельзя передавать никаких значений. Имена класса и конструктора идентично, а у деструктора добавляется приставка ~. Есть дефолтный конструктор, в который мы не передаём никаких значений. 

	5) В языке Си есть слова malloc и free для динамического выделения памяти и удаления. Такие же аналоги есть и в языке С++ для работы с памятью. Это new и delete. new выделяет память и возвращает адрес, где хранится переменная.

	6) This это неявно определённый указатель на сам объект. С его помощью метод класса определяет, с данными какого объекта ему предстоит работать. Он содержит указатель на объекта, который вызывается методом класса. 

	7) std::cin и std::cout нужны для ввода и вывода. Они содержатся в библиотеке iostream. Если бы мы написали using namespace std, мы бы не писали std::, но вдруг какие-то имена совпадут при таком подключении, так что лучше будем писать через std::