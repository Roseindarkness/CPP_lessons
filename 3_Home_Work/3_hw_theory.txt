0. Lvalue и Rvalue ссылки.
Это выражения находящиеся справа(right) и слева(left) от оператора присваивания.
lvalue представляет собой объект, который занимает идентифицируемое место в памяти (например, имеет адрес).
rvalue — это выражение, которое не представляет собой объект, который занимает идентифицируемое место в памяти.

int a;
int& ref1 = a;  // это lvalue ссылка

Если после некоторого типа поместить &&, то получится rvalue ссылка.

int a;
int&& ref2 = a;  // это rvalue ссылка

Rvalue ссылка ведет себя точно так же, как и lvalue ссылка, за исключением того, что она может быть связана с временным объектом, тогда как lvalue связать с временным (не константным) объектом нельзя.

1. Списки инициализации -  метод инициализации переменных-членов класса вместо присваивания им значений после объявления.

 Values() : m_value(10)

Кроме того, списки инициализации позволяют инициализировать константы, которым нельзя присваивать значения

2. Мы знаем следующие типы конструкторов: дефолтный (default constructor), конструктор копирования (copy constructor), виртуальный конструктор (virtual constructor), move конструктор
Дефолтный конструктор - это конструктор, который запускает конструктор от всех составляющих частей. Он просто есть.
Конструктор копирования используется для инициализации одного объекта другим.
По умолчанию при инициализации одного объекта другим С++ выполняет побитовое копирова­ние. Но такой способ далеко не всегда может использоваться. Например, если при инициализации объекта динамически выделяется память, то копия объекта будет ссылаться на тот же участок памяти.
Для решения подобных проблем язык С++ позволяет создать конструктор копирования, кото­рый используется компилятором, когда один объект инициализирует другой. При наличии кон­структора копирования побитовое копирование не выполняется. Конструктор копирования может иметь также дополнительные параметры, если для них определены значения по умолча­нию. Однако в любом случае первым параметром должна быть ссылка на объект, выполняющий инициализацию.

Move constructor вызывается вместо конструктора копирования в случае, когда объект, из которого создается копия, вот-вот будет уничтожен. В таком конструкторе обычно данные из временного объекта переносятся в новый объект, а не копируютя, а полям временного объекта присваиваются валидные значения (например, указателям присваиваются значения nullptr). При выходе из move constructor оба объекта должны оставаться валидными и для обоих должен корректно отрабатывать деструктор. Ссылка T&& называется rvalue reference и означает ссылку на объект, который вот-вот будет уничтожен.

3. Использование const в методах классов позволяет гарантировать, что функция не меняет значений аргумента или поля класса.
Функция int func1(const Class_name& c) не изменяет поля класса по ссылке с.
Const после объявления метода класса ( size_t size() const;) показывает, что данный метод не изменяет поля класcа.


4. Оператор в С++ - это некоторое действие или функция обозначенная специальным символом. Для того что бы распространять эти действия на новые типы данных, при этом сохраняя естественный синтаксис, в С++ была введена возможность перегрузки операторов. 

Имеются некоторые ограничения на перегрузку операторов. Во-первых, нельзя изменить при­оритет оператора. Во-вторых, нельзя изменить число операндов оператора. 
Операторы . :: * ? не могут быть перегружены. А так же такие уникальные символы как || и && не перегружаютися, иначе потеряют свой смысл.

5. Ключевое слово friend используется в объявлении функции, не являющейся методом класса, для предоставления доступа к полю private (Также может использоваться для предоставления другому классу доступа к полю private данного класса). Так, например, можно определить функцию

friend std::ostream& operator<<(std::ostream& os, const Class_name& c);

которая не является методом класса Class_name, но имеет доступ к его полю private.

6. Главное отличие new и delete по сравнению с malloc() и free() в том, что, кроме выделения и освобождения памяти, new и delete вызывают соответственно конструктор и деструктор типа (класса).
Также в случае неудачи new генерирует исключение bad_alloc, а malloc просто возвращает NULL.